## 版本
* JDK1.8之前是数组+链表
* JDK1.8之后是数组+链表+红黑树，为了优化查询效率【当哈希碰撞较多时】
* HashMap构造时，并没初始化容量，是因为懒加载机制，在第一次添加数据时才设置容量
* 默认容量是1<<4，也就是16
##哈希
* hash: 就是把任意长度的输入(又叫做预映射pre-image), 通过 **散列算法**, 变成固定长度的输出(int), 该输出就是散列值.
    这种转换是有一种压缩映射, 也就是说, 散列值的空间远小于输入值. 所以容易出现重复散列值(碰撞)
    * 应用 - 哈希表:数据结构中, 数组 - 寻址容易, 插入删除困难. 链表 - 寻址困难, 插入删除容易. 那么有没有寻址容易, 插入删除也容易的数据结构? 哈希表
  * 哈希表: 实现方法很多, 最常用的"链表法" -> 存储链表的数组(就是HashMap).根据元素特征计算元素的数组下标的方法就是 **散列法**
* hashCode Object 类针对不同的对象返回不同的整数(对象的内存地址转换成整数)
* java 中 Collection 分三类:List, Queue, Set. 前两个元素有序, 可重复. 最后一个元素 **无序**, 不可重复. 保证元素不重复用到的判断 Object.equals.
  * 不可重复的集合存入数据的步骤:
  * 1. 计算传进来的元素的hashCode, 找到数组里的位置, 位置上没数据, 直接存
  * 2. 位置上有数据, 调用 equals() 比较, 相同就跳过, 不同就存(Java中HashSet, HashMap, HashTable的实现是放在表头)
* hashCode, 系统用来 **快速** 检测两个对象是否一致[参考](https://blog.csdn.net/justloveyou_/article/details/52464440)
来自于 public native int hashCode();
同一个类没被回收时, hashCode 保持一致
同一个类被再次创建(如 DialogFragment 再次打开), 即使此刻app活着, hashCode 依然改变
* 散列法
  * 容量, 哈希表中桶的大小(table数组的大小), 为2的n次方.
  * 负载因子, 用于衡量散列表的空间的使用程度(使用到了多少%开始扩容), 默认0.75
  * 哈希表扩容时, 阈值 = 容量 * 负载因子
  * 对于拉链法的哈希表, 查找一个元素的平均时间时间 O(1+a), a 是链表长度.
    * 特别的, 若负载因子越大, 那么, 对空间利用越充分, 查找效率也越低
    * 若负载因子越小, 那么, 对空间造成的浪费越严重. 所以默认的0.75是这种, 不需要去改
* 发生碰撞:
  * open hashing, 单独链表法, 将散列到同一个存储位置的所有元素保存在一个链表.
    实现时一种策略是散列表同一位置的冲突都放进一个栈, 新元素放在前端还是后端取决于怎么方便
  * close hashing = opened address, 开地址法, 继续找, 找到空的位置
*
* HashMap, 在计算出hash值后
  * put时,数据尽量均匀分布以便于查找, 于是想到取模, 但是取模消耗太大, 于是
  ```
  static int indexFor(int h, int length) {
        return h & (length-1);
  }
  ```
  这样做的好处是相当于取模且效率高于取模.
  同时容量为2的n次方的原因也是这个.
  当 length = 15时, length - 1 = 14
  h | length-1 | h&lengeh-1 |result
  --|--|--|--
  0|14|0000 & 1110 = 0000|0
  0|14|0001 & 1110 = 0000|0
  0|14|0010 & 1110 = 0010|2
  0|14|0011 & 1110 = 0010|2
  0|14|0100 & 1110 = 0100|4
  0|14|0101 & 1110 = 0100|4
  0|14|0110 & 1110 = 0110|6
  0|14|0111 & 1110 = 0110|6
  0|14|1000 & 1110 = 1000|8
  0|14|1001 & 1110 = 1000|8
  0|14|1010 & 1110 = 1010|10
  0|14|1011 & 1110 = 1010|10
  0|14|1100 & 1110 = 1100|12
  0|14|1101 & 1110 = 1100|12
  0|14|1110 & 1110 = 1110|14
  0|14|1111 & 1110 = 1110|14
  共发生了 8 次碰撞, 空间的浪费也是一半, 而选择 2 的 n 次方作为 length 时, 不容易发生碰撞
  * HashMap 数据唯一, 因为 put 迭代时 key 相同则覆盖.
### * HashMap, 底层是哈希表, 可存 null(hashCode设为0而已), 为了快速查找而设计的.
