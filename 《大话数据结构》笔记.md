# 《大话数据结构》笔记
## 一、绪论
* 数据项：数据不可分割的最小单位（真正讨论时数据元素才是着眼点），一个数据元素可以有若干个数据项（人有口、鼻、手这些数据项）
* 数据元素：组成数据的，有一定意义的基本单位
#### 逻辑结构
* 集合结构：各个数据元素是均等的，共同属性是同属于一个集合
* 线性结构：一对一的关系
* 树形结构：一对多的关系
* 图形结构：多对多的关系

#### 物理结构（存储结构）
是指数据的`逻辑结构`在计算机中的存储形式
* 顺序存储结构：把数据元素存放在连续的存储单元，逻辑关系与物理关系是一致的
* 链式存储结构：把数据元素存放在任意的存储单元，单元可连续可不连续。无法反应逻辑关系，因此需要指针。

#### 对比
逻辑结构面向问题，物理结构面向计算机



## 二、算法
解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表现为一个或者多个操作
* 五个基本特性：输入、输出、有穷性、确定性、可行性。
* 设计要求：正确性、可读性、健壮性、效率高和存储量低
* 度量方法：事后统计和事前估算（主要）

### 时间复杂度
如果没有说明，都是算最坏时间复杂度
如果没有托名，算法复杂度=时间复杂度，但是，空间复杂度也用O(x)表示

### 推导大O阶的方法
1. 用常数1取代运行时间中的所有加法常数
2. 在修改后的运行次数函数中只保留最高项
3. 如果最高阶项存在且不是1，则去除与这个项相乘的常数

* 常数阶O(1), 只要与n无关，执行次数是恒定的。
* 对数阶O(logn),如n=n*2, 得出2的x次方=n, x=log2n
* 平方阶O(n2), 循环嵌套


## 三、线性表List
0个或多个元素的有限序列，0为空表.有唯一前驱和唯一后继元素
### 顺序存储结构

特点：相邻的元素存储位置也是相邻的
* 存取时间为O(1)
线性表中数据在存储中的位置满足固定关系，第i个数据可以直接推算出，因此对每个位置的存
取数据花费的时间是相同的，存取时间是一个常数，所以是O(1), 也称为随机存取结构
* 增删时间为O(n)
插入删除时，尾部是O(1), 头部是O(n), 合在一起是(n+1)/2，也就是O(n)

### 链式存储结构
#### 单链表
* 存储数据的数据域+存储直接后继数据信息（如指针）的指针域，称为结点Node, 每个结点只包含一个指针域称为单链表。
* 第一个结点 **之前的结点** 称为头结点，最后一个结点的指针域为NULL，头结点的数据域可以不存储任何东西也可以存储链表长度，头指针指链表指向第一个结点的指针，头指针具有标志作用，必要元素，头结点非必要。
* 存取时间为O(n)
查第i个元素, 查找只能从头找, 取第一个元素是1, 取第n个元素是n-1, 合起来是(n-1+1)/2, 也因为单链表结构没有定义表长，就不知道要循环多少次，无法用for循环。
* 增删时间为O(1)
直接让前一个结点的指针指向增加的结点，增加的结点指向前一个结点原本指向的结点。

#### 静态链表
用数组描述的链表，游标实现法
比如两个数组一个存数据，一个存下标。
* 存取时间因为失去了随机存储的特性
* 插入删除则只需要修改下标。


#### 循环链表
单链表终点结点的指针地址改为头结点的地址。

#### 双向链表
解决单链表从中间某个点往前遍历


## 四、栈与队列
### 栈stack
是限定仅在表为进行插入和删除操作的线性表, 比如网页的back
允许插入删除的一端称为栈顶，另一端称为栈底，也被称为后进先出的线性表LastInFirstOut(LIFO)

#### 栈的顺序存储结构
下标为0的一段做栈底，变化多的放在下标最后
常规的push, pop

#### 栈的链式存储结构
栈只是栈顶用来增删, 单链表的第一个结点记的下一个结点的位置，所以把栈顶放在单链表的头部
顺序栈和链式栈在时间复杂度上都是O(1)

#### 栈的作用
1. 递归 在程序设计语言中实现了递归
2. 计算机的括号计算 遇见左括号就入栈，而后遇到右括号，就让左括号出栈
3. 四则运算表达式
中缀表达式配合栈存储符号，转化为后缀表达式
后缀表达式配合栈存储数字，计算
##### 递归
for也就是迭代, 使用的是循环结构
递归使用的选择结构


### 队列 queue
队列是只允许一端进行插入操作，而在另一端进行删除操作的线性表
FirstInFirstOut(FIFO), 允许插入的一端称为队尾，允许删除的一端称为队头。
#### 队列的顺序存储结构
与线性表相同
#### 循环队列
双指针记录后，会产生数组长度与指针不一致的问题，用循环队列解决
#### 队列的链式存储结构
就是线性表的单链表，只能尾进头出
* 插入删除的时间，都是O(1)，通过循环队列实现

在确认队列长度最大值的情况下，建议用循环队列，如果无法预估队列的长度，用链队列


## 五、串
零个或多个字符组成的有限序列，又名字符串。
逻辑结构与线性表相似，线性表更关注单个元素的操作，串在乎子串的位置，得到子串，替换子串。
串的线性存储结构效性能链式存储结构更高

#### 朴素模式匹配算法
#### KMP算法

## 六、树
n个结点的有限集(n>=0)
n=0时为空树, n>1时, 其余结点可分为m个互不相交的有限集。
* 树的结点包含一个数据元素以及若干指向其子树的分支。结点拥有的子树数称为结点的度(Degree)。度为0的结点称为叶结点(Leaf)或终端结点。度不为0的结点称为非终端结点或分支结点。除根结点外，分支结点也称为内部结点。树的度是树内各结点的度的最大值。
* 结点的子树称为该结点的孩子(Child).相应的，该结点称为孩子结点的双亲。同一个双亲的孩子之间称为兄弟(Sibling)
* 森林是m颗互不相交的子树的集合(m>=0)

### 树的存储结构
1. 双亲表示法
2. 孩子表示法
3. 孩子兄弟表示法

#### 双亲表示法
一段连续地址存储 数据域 data + 指针域 parent(双亲域), 查找parent的时间复杂度O(1), 但是查找结点的孩子得遍历, O(n)。
改进：补充左边的孩子域，或补充右边的孩子域，叫有兄弟域。

#### 孩子表示法
把每个结点的孩子结点排列起来，用单链表存储
单链表的头指针用线性表，采用顺序结构存放进一个一维数组。
child+next 和  data+firstchild
但是对于查找双亲需要遍历整棵树，可以和双亲表示法配合，补充双亲域

#### 孩子兄弟表示法(类似二叉树)
任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟，如果存在，也是唯一的。
data+firstchild+rightsib

### 二叉树
每个结点最多有2颗子树
左子树和右子树树有区别的
即使树中某个结点只含有一颗子树也要区分是左还是右

#### 复杂二叉树
1. 斜树
2. 满二叉树
3. 完全二叉树

##### 斜树
分为左斜树和右斜树
所有结点都为左子树的二叉树叫左斜树，右的叫右斜树

##### 满二叉树
所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上。
所以叶子只能出现在最下层。
非叶子的深度是2.
在同样深度的二叉树中，满二叉树的结点个树最多，叶子数最多。

##### 完全二叉树
满二叉树一定是完全二叉树
对一颗具有n个结点的二叉树按层序编号, 如果编号为i(1 <= i <= n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这颗二叉树称为完全二叉树。
特点:
1. 叶子结点只能出现在最下两层
2. 最下层的叶子一定集中在左部连续位置
3. 倒数二层，若有叶子结点，一定都在右部连续位置
4. 如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况。
5. 同样结点数的二叉树，完全二叉树的深度最小。

#### 二叉树的性质
1. 在二叉树的第i层，至多有2的i-1次方个结点(i>=1), 如1, 2, 4, 8...
2. 深度为k的二叉树，至多有2的k次方-1个结点(k>=1)
3. 对任何一颗二叉树，如果其终端结点数为n0, 度为2的结点数为n2, 则 n0=n2+1;
4. 具有n个结点的完全二叉树的深度为log2n+1
5. 如果对一颗有n个结点的完全二叉树（其深度为log2n+1）的结点按层序编号，（从第1层到第log2n+1层，每层从左到右），对任一结点i（1<=i<=n）有:
    1. 如果i=1, 则结点i是二叉树的根, 无双亲;如果i>1, 则其双亲是结点i/2
    2. 如果2i>n, 则结点i无左孩子(结点i为叶子结点),否则其左孩子是结点2i
    3. 如果2i+1>n, 则结点i无右孩子, 否则其右孩子是结点2i+1.


##### 二叉树的顺序存储结构
用一维数组存储二叉树中的结点，即按照层序编号存储，不存在的写为^.
但是对于右斜树存储为A^B^^^C^^^^^^^D, 所以顺序存储结构用于完全二叉树

##### 二叉树的链式存储结构(二叉链表)
lchild+data+rchild, 也可以补充双亲域称为三叉链表

#### 二叉树的遍历
指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。
1. 前序遍历（先打印再递归）
2. 中序遍历
3. 后序遍历
4. 层序遍历（二叉树编号）

已知前序和后序遍历，是不能确定一颗二叉树的【无法确定左子树还是右子树】

#### 二叉树的建立
对每个结点补充虚结点比如#，使其每个结点都有2个孩子，称这种树为原来树的扩展树

#### 线索二叉树（释放空指针域，节省空间）
指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索二叉树
就是将一颗二叉树转变成一个双向链表。
我们对二叉树进行某种次序的遍历使其变为线索二叉树的过程称为线索化。
lchild|ltag|data|rtag|rchild,tag表示child指向的是前驱/后继还是孩子

#### 线索化结构的实现
遍历的过程中修改指针

#### 树、森林、二叉树的转换
树的孩子兄弟法可以将一棵树用二叉链表进行存储。
1. 树转二叉树
2.


##### 树转二叉树
1. 加线。在所有兄弟结点之间加一条连线。
2. 去线。对树中的每一个结点，只保留它与第一个孩子结点的连线。删除它与其他孩子结点之间的连线。
3. 层次跳转。以树的根结点为轴心，将整棵树顺时针旋转一定角度，使之结构层次分明。（注意，第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子）

##### 森林转二叉树
1. 把每一棵树转二叉树
2. 第一棵树不动，依次把后一颗二叉树的根结点作为前一个树的根结点的右孩子

##### 二叉树转换为树
逆操作
1. 加线。某结点的左孩子存在，则将这个左孩子的右孩子以及后孩子的右孩子的右孩子等等，与该结点连起来
2. 去线。删除原二叉树中所有结点与其右孩子结点的连线。
3. 层次调整

##### 二叉树转换为森林
先判断根结点是否有右孩子，有就可以是森林
1. 去孩子。删除根结点及其右孩子以及右孩子的右孩子的线。
2. 二叉树转树。

#### 树与森林的遍历
1. 树的遍历分两种
    1. 先根遍历树
    2. 后根遍历树

2. 森林的遍历分两种
    1. 前序遍历
    2. 后序遍历

当用二叉链表作为存储结构时，树的先根遍历和后根遍历可以借助于二叉树的前序遍历和中序遍历算法

### 赫夫曼树（或哈夫曼或最优二叉树）
带权路径长度WPL最小的二叉树
根结点到该结点所经过的结点数(包扩该结点)x权重的和
#### 赫夫曼树的创造
1. 先把有权值的叶子结点从小到大排成一个有序序列
2. 取头两个权值最小的结点作为一个新结点，这两个结点作为新结点的左右子树，新结点的权值为两个叶子权值和
3. 重复1+2

##### 赫夫曼编码
最初为了解决电报远距离通信的数据传输最优化问题。
1. 根据字母出现频率作为权重，构造赫夫曼树。
2. 将左子树的权重改为0，右子树的权重改为1


## 图
**图** 按照有无方向分为 **无向图** 和 **有向图** ，无向图由 **顶点** 和 **边** 构成，有向图由顶点和 **弧** 构成。弧由 **弧头** 和 **弧尾** 之分。
图按照边或弧的多少分为 **稀疏图** 和 **稠密图**（相对概念），如果任意两个顶点之间都存在边，称为 **完全图**，有向的叫 **有向完全图**，若无重复的边或者顶点到自身的边，则叫 **简单图**
图中顶点之间有 **临接点**、**依附** 的概念，无向图顶点的边数叫 **度**，有向图顶点分为 **入度** 和 **出度**。
图上的边或弧上带 **权** 则称为 **网**。
图中顶点之间存在 **路径**，两顶点之间存在路径则说明是 **连通** 的，如果路径最终回到起始点则称为 **环**，当中不重复叫 **简单路径**，若任意两顶点都是连通的，则图是 **连通图**，有向则称 **强连通图**。图中有子图，若子图极大连通则就是 **连通分量**。有向的则称 **强连通分量**。
无向图中连通且 **n** 个顶点 **n-1** 条边叫 **生成树**。有向图中一顶点入度为0其余顶点入度为1的叫 **有向树**。一个有向图由若干个有向树构成 **生成森林**。

### 图的存储结构
1. 邻接矩阵
2. 邻接表
3. 边集数组
4. 十字链表
5. 邻接多重表

### 图的遍历
1. 深度
2. 广度

### 图的应用
1. 最小生成树
2. 最短路径
3. 有向无环图

#### 最小生成树
1. 普里姆算法(Prim)
2. 克鲁斯卡尔算法(Kruskal)

#### 最短路径
1. 迪杰斯特拉算法(Dijkstra)
2. 弗洛伊德算法(Floyd)

##### 勘误
P216页的图7-2-6不是有向完全图, 其含有四个顶点, 所含有的边是应该是4x(4-1)=12条，但是图中只有10条，缺少了BD之间的弧


## 查找
### 概论
1. 查找表(Search Table)是由同一类型的数据元素（或记录）构成的集合
2. 关键字（Key）是数据元素中某个数据项的值，又称键值。也可以标识一个记录的某个数据项，称为关键码。
3. 若关键字可以唯一的标识一个记录，称为主关键字(Primary Key)
4. 静态查找表。只做查找操作的查找表。(Static Search Table)
5. 动态查找表。在查找的过程中同时插入/删除元素。(Dynamic Search Table)

逻辑上来说查找基于集合，而集合中的元素没有本质关系，因为不得不针对集合建立表、树等结构。
例如对于静态查找表，不妨用线性表组织数据，顺序查找算法。再对主关键字排序，则用折半查找算法。
对于动态表，则用二叉排序树，或者散列表

### 查找算法
#### 顺序表查找
1. 顺序表查找算法。
也称为线性查找。对数组进行常规的for循环判断
2. 顺序表查找优化
取数组第0或者最末位元素，作为哨兵，while循环判断是否和哨兵相等来判断循环结束，时间复杂度还是O(n)

#### 有序表查找
1. 折半查找/二分查找(Binary Search)
前提是关键字有序，线性表必须采用顺序存储。此时类比于一颗完全二叉树，根据概念4，此时的深度是log2n, 也就是时间复杂度为O(logn).
缺点：因为需要排序，适用于静态表。对于有插入删除操作的就不适用了。
2. 插值查找
折半查找的核心是mid=low+(high-low)/2, 将1/2替换为(key-a[low])/(a[high]-a[low])得到插值查找。
是将关键字与查找表中最大值最小值比较后的算法。时间复杂度也是O(logn), 对于分布均匀的数据较快，但是对于计算不均匀的数据未必是个合适的选择。
3. 斐波那契查找
时间复杂度也是O(logn), 缺点是如果数据在左侧长半区，则效率低于折半查找。
4. 但是
折半查找是加法和除法运算(low+high)/2
插值查找是复杂的四则运算(key-a[low])/(a[high]-a[low])
斐波那契查找只是加法运算low+F[k-1]-1
Â
### 线性索引查找
大量的数据主张先存储后排序，对于这样的表查找依靠的是索引。
#### 索引
索引就是把一个关键字与它对应的记录相关联的过程。分线性索引、树形索引、多级索引。
线性索引就是将索引项集合组织为线性结构，也称为索引表。
1. 稠密索引
2. 分块索引
3. 倒排索引

##### 稠密索引
将数据集中的每一个记录对应一个索引项。索引项一定是按照关键码的有序排列。
优点：使用线性表操作
缺点：担心数据集过于庞大

##### 分块索引
块内无序，块间有序
结构为：
1. 最大关键码。它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中的最小关键字也能比这一块的最大关键字大。
2. 存储了块中的记录个数。
3. 用于指向块首数据元素的指针。

查找过程：
1. 块间有序，折半插值查找。
2. 块中无序，顺序查找。
时间复杂度O(根号n), 被广泛应用

##### 倒排索引
索引结构：
1. 次关键字码
2. 记录号表

#### 二叉排序树
对一个二叉树进行中序遍历，
1. 左子树不为空，则左子树上所有结点的值均小于它的根结构的值
2. 右子树不为空，则右子树上所有结点的值均小于它的根结构的值
3. 左右子树也分别为二叉排序树
缺点：右斜树效率低下，所以希望二叉排序树是平衡的

#### 平衡二叉树（AVL树）
左子树和右子树深度之差的绝对值不超过1的二叉排序树
**平衡因子**：结点的左子树深度减去右子树深度的值 BF,Balance Factor
最小不平衡子树：距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树
实现：每插入一个结点，先检查是否因插入而破坏了树的平衡性。若是，则找出最小不平衡子树，调整关系，旋转等。
查找时间是O(logn)
插入和删除时间是O(logn)















[Ref Android技能树 — 排序算法基础小结](https://www.jianshu.com/p/64df18cddf1f)
