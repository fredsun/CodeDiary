# 《大话数据结构》笔记
## 一、绪论
* 数据项：数据不可分割的最小单位（真正讨论时数据元素才是着眼点），一个数据元素可以有若干个数据项（人有口、鼻、手这些数据项）
* 数据元素：组成数据的，有一定意义的基本单位
#### 逻辑结构
* 集合结构：各个数据元素是均等的，共同属性是同属于一个集合
* 线性结构：一对一的关系
* 树形结构：一对多的关系
* 图形结构：多对多的关系

#### 物理结构（存储结构）
是指数据的`逻辑结构`在计算机中的存储形式
* 顺序存储结构：把数据元素存放在连续的存储单元，逻辑关系与物理关系是一致的
* 链式存储结构：把数据元素存放在任意的存储单元，单元可连续可不连续。无法反应逻辑关系，因此需要指针。

#### 对比
逻辑结构面向问题，物理结构面向计算机



## 二、算法
解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表现为一个或者多个操作
* 五个基本特性：输入、输出、有穷性、确定性、可行性。
* 设计要求：正确性、可读性、健壮性、效率高和存储量低
* 度量方法：事后统计和事前估算（主要）

### 时间复杂度
如果没有说明，都是算最坏时间复杂度
如果没有托名，算法复杂度=时间复杂度，但是，空间复杂度也用O(x)表示

### 推导大O阶的方法
1. 用常数1取代运行时间中的所有加法常数
2. 在修改后的运行次数函数中只保留最高项
3. 如果最高阶项存在且不是1，则去除与这个项相乘的常数

* 常数阶O(1), 只要与n无关，执行次数是恒定的。
* 对数阶O(logn),如n=n*2, 得出2的x次方=n, x=log2n
* 平方阶O(n2), 循环嵌套


## 三、线性表List
0个或多个元素的有限序列，0为空表.有唯一前驱和唯一后继元素
### 顺序存储结构

特点：相邻的元素存储位置也是相邻的
* 存取时间为O(1)
线性表中数据在存储中的位置满足固定关系，第i个数据可以直接推算出，因此对每个位置的存
取数据花费的时间是相同的，存取时间是一个常数，所以是O(1), 也称为随机存取结构
* 增删时间为O(n)
插入删除时，尾部是O(1), 头部是O(n), 合在一起是(n+1)/2，也就是O(n)

### 链式存储结构
#### 单链表
* 存储数据的数据域+存储直接后继数据信息（如指针）的指针域，称为结点Node, 每个结点只包含一个指针域称为单链表。
* 第一个结点 **之前的结点** 称为头结点，最后一个结点的指针域为NULL，头结点的数据域可以不存储任何东西也可以存储链表长度，头指针指链表指向第一个结点的指针，头指针具有标志作用，必要元素，头结点非必要。
* 存取时间为O(n)
查第i个元素, 查找只能从头找, 取第一个元素是1, 取第n个元素是n-1, 合起来是(n-1+1)/2, 也因为单链表结构没有定义表长，就不知道要循环多少次，无法用for循环。
* 增删时间为O(1)
直接让前一个结点的指针指向增加的结点，增加的结点指向前一个结点原本指向的结点。

#### 静态链表
用数组描述的链表，游标实现法
比如两个数组一个存数据，一个存下标。
* 存取时间因为失去了随机存储的特性
* 插入删除则只需要修改下标。


#### 循环链表
单链表终点结点的指针地址改为头结点的地址。

#### 双向链表
解决单链表从中间某个点往前遍历


## 四、栈与队列
### 栈stack
是限定仅在表为进行插入和删除操作的线性表, 比如网页的back
允许插入删除的一端称为栈顶，另一端称为栈底，也被称为后进先出的线性表LastInFirstOut(LIFO)

#### 栈的顺序存储结构
下标为0的一段做栈底，变化多的放在下标最后
常规的push, pop

#### 栈的链式存储结构
栈只是栈顶用来增删, 单链表的第一个结点记的下一个结点的位置，所以把栈顶放在单链表的头部
顺序栈和链式栈在时间复杂度上都是O(1)

#### 栈的作用
1. 递归 在程序设计语言中实现了递归
2. 计算机的括号计算 遇见左括号就入栈，而后遇到右括号，就让左括号出栈
3. 四则运算表达式
中缀表达式配合栈存储符号，转化为后缀表达式
后缀表达式配合栈存储数字，计算
##### 递归
for也就是迭代, 使用的是循环结构
递归使用的选择结构


### 队列 queue
队列是只允许一端进行插入操作，而在另一端进行删除操作的线性表
FirstInFirstOut(FIFO), 允许插入的一端称为队尾，允许删除的一端称为队头。
#### 队列的顺序存储结构
与线性表相同
#### 循环队列
双指针记录后，会产生数组长度与指针不一致的问题，用循环队列解决
#### 队列的链式存储结构
就是线性表的单链表，只能尾进头出
* 插入删除的时间，都是O(1)，通过循环队列实现

在确认队列长度最大值的情况下，建议用循环队列，如果无法预估队列的长度，用链队列


## 五、串
零个或多个字符组成的有限序列，又名字符串。
逻辑结构与线性表相似，线性表更关注单个元素的操作，串在乎子串的位置，得到子串，替换子串。
串的线性存储结构效性能链式存储结构更高

#### 朴素模式匹配算法
#### KMP算法

## 六、树
n个结点的有限集(n>=0)
n=0时为空树, n>1时, 其余结点可分为m个互不相交的有限集。
* 树的结点包含一个数据元素以及若干指向其子树的分支。结点拥有的子树数称为结点的度(Degree)。度为0的结点称为叶结点(Leaf)或终端结点。度不为0的结点称为非终端结点或分支结点。除根结点外，分支结点也称为内部结点。树的度是树内各结点的度的最大值。
* 结点的子树称为该结点的孩子(Child).相应的，该结点称为孩子结点的双亲。同一个双亲的孩子之间称为兄弟(Sibling)
* 森林是m颗互不相交的子树的集合(m>=0)

### 树的存储结构
1. 双亲表示法
2. 孩子表示法
3. 孩子兄弟表示法

#### 双亲表示法
一段连续地址存储 数据域 data + 指针域 parent(双亲域), 查找parent的时间复杂度O(1), 但是查找结点的孩子得遍历, O(n)。
改进：补充左边的孩子域，或补充右边的孩子域，叫有兄弟域。

#### 孩子表示法
把每个结点的孩子结点排列起来，用单链表存储
单链表的头指针用线性表，采用顺序结构存放进一个一维数组。
child+next 和  data+firstchild
但是对于查找双亲需要遍历整棵树，可以和双亲表示法配合，补充双亲域

#### 孩子兄弟表示法(类似二叉树)
任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟，如果存在，也是唯一的。
data+firstchild+rightsib

### 二叉树
每个结点最多有2颗子树
左子树和右子树树有区别的
即使树中某个结点只含有一颗子树也要区分是左还是右

#### 复杂二叉树
1. 斜树
2. 满二叉树
3. 完全二叉树

##### 斜树
分为左斜树和右斜树
所有结点都为左子树的二叉树叫左斜树，右的叫右斜树

##### 满二叉树
所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上。
所以叶子只能出现在最下层。
非叶子的深度是2.
在同样深度的二叉树中，满二叉树的结点个树最多，叶子数最多。

##### 完全二叉树
满二叉树一定是完全二叉树
对一颗具有n个结点的二叉树按层序编号, 如果编号为i(1 <= i <= n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这颗二叉树称为完全二叉树。
特点:
1. 叶子结点只能出现在最下两层
2. 最下层的叶子一定集中在左部连续位置
3. 倒数二层，若有叶子结点，一定都在右部连续位置
4. 如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况。
5. 同样结点数的二叉树，完全二叉树的深度最小。

#### 二叉树的性质
1. 在二叉树的第i层，至多有2的i-1次方个结点(i>=1), 如1, 2, 4, 8...
2. 深度为k的二叉树，至多有2的k次方-1个结点(k>=1)
3. 对任何一颗二叉树，如果其终端结点数为n0, 度为2的结点数为n2, 则 n0=n2+1;
4. 具有n个结点的完全二叉树的深度为log2n+1
5. 如果对一颗有n个结点的完全二叉树（其深度为log2n+1）的结点按层序编号，（从第1层到第log2n+1层，每层从左到右），对任一结点i（1<=i<=n）有:
    1. 如果i=1, 则结点i是二叉树的根, 无双亲;如果i>1, 则其双亲是结点i/2
    2. 如果2i>n, 则结点i无左孩子(结点i为叶子结点),否则其左孩子是结点2i
    3. 如果2i+1>n, 则结点i无右孩子, 否则其右孩子是结点2i+1.


##### 二叉树的顺序存储结构
用一维数组存储二叉树中的结点，即按照层序编号存储，不存在的写为^.
但是对于右斜树存储为A^B^^^C^^^^^^^D, 所以顺序存储结构用于完全二叉树

##### 二叉树的链式存储结构(二叉链表)
lchild+data+rchild, 也可以补充双亲域称为三叉链表

#### 二叉树的遍历
指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。
1. 前序遍历（先打印再递归）
2. 中序遍历
3. 后序遍历
4. 层序遍历（二叉树编号）

已知前序和后序遍历，是不能确定一颗二叉树的【无法确定左子树还是右子树】

#### 二叉树的建立
对每个结点补充虚结点比如#，使其每个结点都有2个孩子，称这种树为原来树的扩展树

#### 线索二叉树（释放空指针域，节省空间）
指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索二叉树
就是将一颗二叉树转变成一个双向链表。
我们对二叉树进行某种次序的遍历使其变为线索二叉树的过程称为线索化。
lchild|ltag|data|rtag|rchild,tag表示child指向的是前驱/后继还是孩子

#### 线索化结构的实现
遍历的过程中修改指针

#### 树、森林、二叉树的转换
树的孩子兄弟法可以将一棵树用二叉链表进行存储。
1. 树转二叉树
2.


##### 树转二叉树
1. 加线。在所有兄弟结点之间加一条连线。
2. 去线。对树中的每一个结点，只保留它与第一个孩子结点的连线。删除它与其他孩子结点之间的连线。
3. 层次跳转。以树的根结点为轴心，将整棵树顺时针旋转一定角度，使之结构层次分明。（注意，第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子）

##### 森林转二叉树
1. 把每一棵树转二叉树
2. 第一棵树不动，依次把后一颗二叉树的根结点作为前一个树的根结点的右孩子

##### 二叉树转换为树
逆操作
1. 加线。某结点的左孩子存在，则将这个左孩子的右孩子以及后孩子的右孩子的右孩子等等，与该结点连起来
2. 去线。删除原二叉树中所有结点与其右孩子结点的连线。
3. 层次调整

##### 二叉树转换为森林
先判断根结点是否有右孩子，有就可以是森林
1. 去孩子。删除根结点及其右孩子以及右孩子的右孩子的线。
2. 二叉树转树。

#### 树与森林的遍历
1. 树的遍历分两种
    1. 先根遍历树
    2. 后根遍历树

2. 森林的遍历分两种
    1. 前序遍历
    2. 后序遍历

当用二叉链表作为存储结构时，树的先根遍历和后根遍历可以借助于二叉树的前序遍历和中序遍历算法

### 赫夫曼树（或哈夫曼或最优二叉树）
带权路径长度WPL最小的二叉树
根结点到该结点所经过的结点数(包扩该结点)x权重的和
#### 赫夫曼树的创造
1. 先把有权值的叶子结点从小到大排成一个有序序列
2. 取头两个权值最小的结点作为一个新结点，这两个结点作为新结点的左右子树，新结点的权值为两个叶子权值和
3. 重复1+2

##### 赫夫曼编码
最初为了解决电报远距离通信的数据传输最优化问题。
1. 根据字母出现频率作为权重，构造赫夫曼树。
2. 将左子树的权重改为0，右子树的权重改为1











[Ref Android技能树 — 排序算法基础小结](https://www.jianshu.com/p/64df18cddf1f)
